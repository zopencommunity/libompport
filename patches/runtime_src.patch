diff --git a/runtime/src/CMakeLists.txt b/runtime/src/CMakeLists.txt
index 698e185..319a8f0 100644
--- a/runtime/src/CMakeLists.txt
+++ b/runtime/src/CMakeLists.txt
@@ -124,7 +124,7 @@ else()
     if(${CMAKE_SYSTEM_NAME} MATCHES "AIX")
       libomp_append(LIBOMP_GNUASMFILES z_AIX_asm.S) # AIX assembly file
     else()
-      libomp_append(LIBOMP_GNUASMFILES z_Linux_asm.S) # Unix assembly file
+        #libomp_append(LIBOMP_GNUASMFILES z_Linux_asm.S) # Unix assembly file
     endif()
   endif()
   libomp_append(LIBOMP_CXXFILES thirdparty/ittnotify/ittnotify_static.cpp LIBOMP_USE_ITT_NOTIFY)
diff --git a/runtime/src/kmp.h b/runtime/src/kmp.h
index 197cf54..47ff58f 100644
--- a/runtime/src/kmp.h
+++ b/runtime/src/kmp.h
@@ -1421,6 +1421,10 @@ extern kmp_uint64 __kmp_now_nsec();
 /* TODO: tune for KMP_OS_AIX */
 #define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */
 #define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */
+#elif KMP_OS_ZOS
+/* TODO: tune for KMP_OS_ZOS */
+#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */
+#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */
 #endif
 
 #if KMP_ARCH_X86 || KMP_ARCH_X86_64
diff --git a/runtime/src/kmp_affinity.cpp b/runtime/src/kmp_affinity.cpp
index 5038950..61ef895 100644
--- a/runtime/src/kmp_affinity.cpp
+++ b/runtime/src/kmp_affinity.cpp
@@ -1434,6 +1434,7 @@ void KMPAffinity::Mask::operator delete[](void *p) { __kmp_free(p); }
 void *KMPAffinity::operator new(size_t n) { return __kmp_allocate(n); }
 void KMPAffinity::operator delete(void *p) { __kmp_free(p); }
 
+#if KMP_AFFINITY_SUPPORTED
 void KMPAffinity::pick_api() {
   KMPAffinity *affinity_dispatch;
   if (picked_api)
@@ -1453,6 +1454,7 @@ void KMPAffinity::pick_api() {
   __kmp_affinity_dispatch = affinity_dispatch;
   picked_api = true;
 }
+#endif // KMP_AFFINITY_SUPPORTED
 
 void KMPAffinity::destroy_api() {
   if (__kmp_affinity_dispatch != NULL) {
diff --git a/runtime/src/kmp_barrier.h b/runtime/src/kmp_barrier.h
index ae9b8d6..9b5cc10 100644
--- a/runtime/src/kmp_barrier.h
+++ b/runtime/src/kmp_barrier.h
@@ -15,6 +15,12 @@
 
 #include "kmp.h"
 #include "kmp_i18n.h"
+#include <stdlib.h> // Explicitly include stdlib.h
+
+#if KMP_OS_ZOS
+#undef KMP_HAVE_ALIGNED_ALLOC
+#define KMP_HAVE_ALIGNED_ALLOC 0
+#endif
 
 #if KMP_HAVE_XMMINTRIN_H && KMP_HAVE__MM_MALLOC
 #include <xmmintrin.h>
diff --git a/runtime/src/kmp_config.h.cmake b/runtime/src/kmp_config.h.cmake
index d64c9a4..f2320dd 100644
--- a/runtime/src/kmp_config.h.cmake
+++ b/runtime/src/kmp_config.h.cmake
@@ -142,7 +142,7 @@
 
 // use shared memory with dynamic library (except Android, where shm_*
 // functions don't exist).
-#if KMP_OS_UNIX && KMP_DYNAMIC_LIB && !__ANDROID__
+#if KMP_OS_UNIX && KMP_DYNAMIC_LIB && !__ANDROID__ && !KMP_OS_ZOS
 #define KMP_USE_SHM
 #endif
 #endif // KMP_CONFIG_H
diff --git a/runtime/src/kmp_ftn_entry.h b/runtime/src/kmp_ftn_entry.h
index 59a9571..e3adb9e 100644
--- a/runtime/src/kmp_ftn_entry.h
+++ b/runtime/src/kmp_ftn_entry.h
@@ -706,7 +706,7 @@ int FTN_STDCALL KMP_EXPAND_NAME(FTN_GET_THREAD_NUM)(void) {
 
 #if KMP_OS_DARWIN || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||    \
     KMP_OS_OPENBSD || KMP_OS_HAIKU || KMP_OS_HURD || KMP_OS_SOLARIS ||         \
-    KMP_OS_AIX
+    KMP_OS_AIX || KMP_OS_ZOS
   gtid = __kmp_entry_gtid();
 #elif KMP_OS_WINDOWS
   if (!__kmp_init_parallel ||
diff --git a/runtime/src/kmp_lock.h b/runtime/src/kmp_lock.h
index 6202f3d..9a0168f 100644
--- a/runtime/src/kmp_lock.h
+++ b/runtime/src/kmp_lock.h
@@ -284,7 +284,7 @@ typedef union kmp_ticket_lock kmp_ticket_lock_t;
 // Note the macro argument. It is important to make var properly initialized.
 #define KMP_TICKET_LOCK_INITIALIZER(lock)                                      \
   {                                                                            \
-    { true, &(lock), NULL, 0U, 0U, 0, -1 }                                     \
+    { {true}, &(lock), NULL, {0U}, {0U}, {0}, {-1} }                                     \
   }
 
 extern int __kmp_acquire_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);
diff --git a/runtime/src/kmp_os.h b/runtime/src/kmp_os.h
index e8ad2a6..cbb82a2 100644
--- a/runtime/src/kmp_os.h
+++ b/runtime/src/kmp_os.h
@@ -13,6 +13,7 @@
 #ifndef KMP_OS_H
 #define KMP_OS_H
 
+#include "kmp_platform.h"
 #include "kmp_config.h"
 #include <atomic>
 #include <stdarg.h>
@@ -163,6 +164,7 @@ typedef unsigned __int64 kmp_uintptr_t;
 #endif /* KMP_OS_WINDOWS */
 
 #if KMP_OS_UNIX
+#include <dlfcn.h> // Required for RTLD_DEFAULT and dlsym
 #define KMP_END_OF_LINE "\n"
 typedef char kmp_int8;
 typedef unsigned char kmp_uint8;
@@ -389,6 +391,9 @@ extern "C" {
 #define KMP_ALIGN(bytes) __declspec(align(bytes))
 #define KMP_THREAD_LOCAL __declspec(thread)
 #define KMP_ALIAS /* Nothing */
+#elif KMP_OS_ZOS
+#define KMP_ALIGN(bytes) __attribute__((aligned(bytes)))
+#define KMP_THREAD_LOCAL
 #else
 #define KMP_ALIGN(bytes) __attribute__((aligned(bytes)))
 #define KMP_THREAD_LOCAL __thread
@@ -1298,6 +1303,9 @@ extern void *__kmp_lookup_symbol(const char *name, bool next = false);
 #elif KMP_OS_WASI || KMP_OS_EMSCRIPTEN
 #define KMP_DLSYM(name) nullptr
 #define KMP_DLSYM_NEXT(name) nullptr
+#elif KMP_OS_ZOS
+#define KMP_DLSYM(name) dlsym(NULL, name)
+#define KMP_DLSYM_NEXT(name) dlsym(NULL, name)
 #else
 #define KMP_DLSYM(name) dlsym(RTLD_DEFAULT, name)
 #define KMP_DLSYM_NEXT(name) dlsym(RTLD_NEXT, name)
diff --git a/runtime/src/kmp_platform.h b/runtime/src/kmp_platform.h
index 609b7c4..368f914 100644
--- a/runtime/src/kmp_platform.h
+++ b/runtime/src/kmp_platform.h
@@ -28,6 +28,7 @@
 #define KMP_OS_WASI 0
 #define KMP_OS_EMSCRIPTEN 0
 #define KMP_OS_AIX 0
+#define KMP_OS_ZOS 0
 #define KMP_OS_UNIX 0 /* disjunction of KMP_OS_LINUX, KMP_OS_DARWIN etc. */
 
 #ifdef _WIN32
@@ -95,6 +96,11 @@
 #define KMP_OS_WASI 1
 #endif
 
+#if (defined __MVS__)
+#undef KMP_OS_ZOS
+#define KMP_OS_ZOS 1
+#endif
+
 #if (defined _AIX)
 #undef KMP_OS_AIX
 #define KMP_OS_AIX 1
@@ -102,13 +108,13 @@
 
 #if (1 != KMP_OS_LINUX + KMP_OS_DRAGONFLY + KMP_OS_FREEBSD + KMP_OS_NETBSD +   \
               KMP_OS_OPENBSD + KMP_OS_DARWIN + KMP_OS_WINDOWS + KMP_OS_HAIKU + \
-              KMP_OS_HURD + KMP_OS_SOLARIS + KMP_OS_WASI + KMP_OS_AIX)
+              KMP_OS_HURD + KMP_OS_SOLARIS + KMP_OS_WASI + KMP_OS_AIX + KMP_OS_ZOS)
 #error Unknown OS
 #endif
 
 #if KMP_OS_LINUX || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||     \
     KMP_OS_OPENBSD || KMP_OS_DARWIN || KMP_OS_HAIKU || KMP_OS_HURD ||          \
-    KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX
+    KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX || KMP_OS_ZOS
 #undef KMP_OS_UNIX
 #define KMP_OS_UNIX 1
 #endif
diff --git a/runtime/src/kmp_runtime.cpp b/runtime/src/kmp_runtime.cpp
index 6afea9b..975c789 100644
--- a/runtime/src/kmp_runtime.cpp
+++ b/runtime/src/kmp_runtime.cpp
@@ -8959,7 +8959,7 @@ __kmp_determine_reduction_method(
 
 #if KMP_OS_LINUX || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||     \
     KMP_OS_OPENBSD || KMP_OS_WINDOWS || KMP_OS_DARWIN || KMP_OS_HAIKU ||       \
-    KMP_OS_HURD || KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX
+    KMP_OS_HURD || KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX || KMP_OS_ZOS
 
     int teamsize_cutoff = 4;
 
@@ -8991,7 +8991,7 @@ __kmp_determine_reduction_method(
 
 #if KMP_OS_LINUX || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||     \
     KMP_OS_OPENBSD || KMP_OS_WINDOWS || KMP_OS_HAIKU || KMP_OS_HURD ||         \
-    KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX
+    KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX || KMP_OS_ZOS
 
     // basic tuning
 
diff --git a/runtime/src/kmp_safe_c_api.h b/runtime/src/kmp_safe_c_api.h
index 79f4a7f..84500b9 100644
--- a/runtime/src/kmp_safe_c_api.h
+++ b/runtime/src/kmp_safe_c_api.h
@@ -13,7 +13,7 @@
 #include <type_traits>
 #include "kmp_platform.h"
 #include <string.h>
-
+#include <stdlib.h>
 // Replacement for banned C API
 
 // Not every unsafe call listed here is handled now, but keeping everything
@@ -56,7 +56,7 @@ template <typename T> struct kmp_get_rmax_t<T, true> {
 
 // For now, these macros use the existing API.
 
-#if KMP_OS_NETBSD
+#if KMP_OS_NETBSD || KMP_OS_ZOS
 #define KMP_ALLOCA __builtin_alloca
 #else
 #define KMP_ALLOCA alloca
diff --git a/runtime/src/kmp_wrapper_getpid.h b/runtime/src/kmp_wrapper_getpid.h
index 9854d61..292c740 100644
--- a/runtime/src/kmp_wrapper_getpid.h
+++ b/runtime/src/kmp_wrapper_getpid.h
@@ -17,7 +17,7 @@
 
 // On Unix-like systems (Linux* OS and OS X*) getpid() is declared in standard
 // headers.
-#if !KMP_OS_AIX && !KMP_OS_HAIKU
+#if !KMP_OS_AIX && !KMP_OS_HAIKU && !KMP_OS_ZOS
 #include <sys/syscall.h>
 #endif
 #include <sys/types.h>
@@ -33,7 +33,7 @@
 #define __kmp_gettid() _lwp_self()
 #elif KMP_OS_OPENBSD
 #define __kmp_gettid() getthrid()
-#elif KMP_OS_AIX || KMP_OS_SOLARIS
+#elif KMP_OS_AIX || KMP_OS_SOLARIS || KMP_OS_ZOS
 #include <pthread.h>
 #define __kmp_gettid() pthread_self()
 #elif KMP_OS_HAIKU
diff --git a/runtime/src/kmp_wrapper_malloc.h b/runtime/src/kmp_wrapper_malloc.h
index 1f75e88..5b017e6 100644
--- a/runtime/src/kmp_wrapper_malloc.h
+++ b/runtime/src/kmp_wrapper_malloc.h
@@ -95,7 +95,7 @@
 #if KMP_MSVC_COMPAT
 #define alloca _alloca // Allow to use alloca() with no underscore.
 #endif
-#elif KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD || KMP_OS_OPENBSD
+#elif KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD || KMP_OS_OPENBSD || KMP_OS_AIX || KMP_OS_ZOS
 // Declared in "stdlib.h".
 #elif KMP_OS_UNIX
 #include <alloca.h> // Linux* OS and OS X*: alloc() declared in "alloca".
diff --git a/runtime/src/ompt-general.cpp b/runtime/src/ompt-general.cpp
index 1a778e4..fa6c5f1 100644
--- a/runtime/src/ompt-general.cpp
+++ b/runtime/src/ompt-general.cpp
@@ -35,6 +35,10 @@
  * macros
  ****************************************************************************/
 
+#if KMP_OS_ZOS && !defined(RTLD_NEXT)
+#define RTLD_NEXT ((void *)-1)
+#endif
+
 #define ompt_get_callback_success 1
 #define ompt_get_callback_failure 0
 
diff --git a/runtime/src/ompt-specific.cpp b/runtime/src/ompt-specific.cpp
index 94ae2e5..af853d3 100644
--- a/runtime/src/ompt-specific.cpp
+++ b/runtime/src/ompt-specific.cpp
@@ -27,6 +27,10 @@
 #define THREAD_LOCAL __thread
 #endif
 
+#if KMP_OS_ZOS
+#include <zos-tls.h>
+#endif
+
 #define OMPT_WEAK_ATTRIBUTE KMP_WEAK_ATTRIBUTE_INTERNAL
 
 //******************************************************************************
@@ -495,7 +499,12 @@ void __ompt_team_assign_id(kmp_team_t *team, ompt_data_t ompt_pid) {
 
 static uint64_t __ompt_get_unique_id_internal() {
   static uint64_t thread = 1;
+#if KMP_OS_ZOS
+static __tlssim<uint64_t> id_tls(0);
+#define ID (*id_tls.access())
+#elif
   static THREAD_LOCAL uint64_t ID = 0;
+#endif
   if (ID == 0) {
     uint64_t new_thread = KMP_TEST_THEN_INC64((kmp_int64 *)&thread);
     ID = new_thread << (sizeof(uint64_t) * 8 - OMPT_THREAD_ID_BITS);
diff --git a/runtime/src/z_Linux_util.cpp b/runtime/src/z_Linux_util.cpp
index 368c0b6..0c3f855 100644
--- a/runtime/src/z_Linux_util.cpp
+++ b/runtime/src/z_Linux_util.cpp
@@ -21,7 +21,7 @@
 #include "kmp_wait_release.h"
 #include "kmp_wrapper_getpid.h"
 
-#if !KMP_OS_DRAGONFLY && !KMP_OS_FREEBSD && !KMP_OS_NETBSD && !KMP_OS_OPENBSD
+#if !KMP_OS_DRAGONFLY && !KMP_OS_FREEBSD && !KMP_OS_NETBSD && !KMP_OS_OPENBSD && !KMP_OS_ZOS
 #include <alloca.h>
 #endif
 #include <math.h> // HUGE_VAL.
@@ -32,7 +32,7 @@
 #if KMP_OS_AIX
 #include <sys/ldr.h>
 #include <libperfstat.h>
-#elif !KMP_OS_HAIKU
+#elif !KMP_OS_HAIKU && !KMP_OS_ZOS
 #include <sys/syscall.h>
 #endif
 #include <sys/time.h>
@@ -864,7 +864,7 @@ void __kmp_create_worker(int gtid, kmp_info_t *th, size_t stack_size) {
 
   status =
       pthread_create(&handle, &thread_attr, __kmp_launch_worker, (void *)th);
-  if (status != 0 || !handle) { // ??? Why do we check handle??
+  if (status != 0 || !handle.__) { // ??? Why do we check handle??
 #ifdef _POSIX_THREAD_ATTR_STACKSIZE
     if (status == EINVAL) {
       __kmp_fatal(KMP_MSG(CantSetWorkerStackSize, stack_size), KMP_ERR(status),
@@ -1851,7 +1851,7 @@ int __kmp_read_system_info(struct kmp_sys_info *info) {
   status = getrusage(RUSAGE_SELF, &r_usage);
   KMP_CHECK_SYSFAIL_ERRNO("getrusage", status);
 
-#if !KMP_OS_WASI
+#if !KMP_OS_WASI && !KMP_OS_ZOS
   // The maximum resident set size utilized (in kilobytes)
   info->maxrss = r_usage.ru_maxrss;
   // The number of page faults serviced without any I/O
@@ -1903,7 +1903,7 @@ static int __kmp_get_xproc(void) {
   __kmp_type_convert(sysconf(_SC_NPROCESSORS_CONF), &(r));
 
 #elif KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD || KMP_OS_OPENBSD || \
-    KMP_OS_HAIKU || KMP_OS_HURD || KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX
+    KMP_OS_HAIKU || KMP_OS_HURD || KMP_OS_SOLARIS || KMP_OS_WASI || KMP_OS_AIX || KMP_OS_ZOS
 
   __kmp_type_convert(sysconf(_SC_NPROCESSORS_ONLN), &(r));
 
@@ -2392,7 +2392,7 @@ int __kmp_is_address_mapped(void *addr) {
   }
   KMP_INTERNAL_FREE(loadQueryBuf);
 
-#elif KMP_OS_HAIKU
+#elif KMP_OS_HAIKU || KMP_OS_ZOS //TODO
 
   found = 1;
 #else
@@ -2512,6 +2512,12 @@ int __kmp_get_load_balance(int max) {
   return running_threads;
 }
 
+#elif KMP_OS_ZOS
+
+int __kmp_get_load_balance(int max) {
+  return -1;
+}
+
 #else // Linux* OS
 
 // The function returns number of running (not sleeping) threads, or -1 in case
@@ -3099,4 +3105,46 @@ bool __kmp_detect_tmp() {
   }
 }
 
+// For !KMP_COMPILER_MSVC, this function is provided in assembly form
+// by z_Linux_asm.S.
+int __kmp_invoke_microtask(microtask_t pkfn, int gtid, int tid, int argc,
+                           void *p_argv[]
+) {
+
+  switch (argc) {
+  case 0:
+    (*pkfn)(&gtid, &tid);
+    break;
+  case 1:
+    (*pkfn)(&gtid, &tid, p_argv[0]);
+    break;
+  case 2:
+    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1]);
+    break;
+  case 3:
+    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2]);
+    break;
+  case 4:
+    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3]);
+    break;
+  case 5:
+    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4]);
+    break;
+  default: {
+    // p_argv[6] and onwards must be passed on the stack since 8 registers are
+    // already used.
+    size_t len = (argc - 6) * sizeof(void *);
+    void *argbuf = __builtin_alloca(len);
+    memcpy(argbuf, &p_argv[6], len);
+  }
+    [[fallthrough]];
+  case 6:
+    (*pkfn)(&gtid, &tid, p_argv[0], p_argv[1], p_argv[2], p_argv[3], p_argv[4],
+            p_argv[5]);
+    break;
+  }
+
+  return 1;
+}
+
 // end of file //
